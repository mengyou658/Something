package com.moons.xst.track.dao;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteStatement;

import com.moons.xst.sqlite.DJDAOSession;
import com.moons.xst.track.bean.Z_DJ_CycleDTL;

import de.greenrobot.dao.AbstractDao;
import de.greenrobot.dao.Property;
import de.greenrobot.dao.internal.DaoConfig;


// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
/** 
 * DAO for table Z_DJ_CYCLE_DTL.
*/
public class Z_DJ_CycleDTLDao extends AbstractDao<Z_DJ_CycleDTL, Void> {

    public static final String TABLENAME = "Z_DJ_CYCLEDTL";

    /**
     * Properties of entity Z_DJ_CycleDTL.<br/>
     * Can be used for QueryBuilder and for referencing column names.
    */
    public static class Properties {
        public final static Property Cycle_ID = new Property(0, String.class, "Cycle_ID", false, "CYCLE_ID");
        public final static Property CycSort_NR = new Property(1, int.class, "CycSort_NR", false, "CYCSORT_NR");
        public final static Property CycStart_TX = new Property(2, String.class, "CycStart_TX", false, "CYCSTART_TX");
        public final static Property SpanValue_NR = new Property(3, int.class, "SpanValue_NR", false, "SPANVALUE_NR");
        public final static Property SpanType_CD = new Property(4, String.class, "SpanType_CD", false, "SPANTYPE_CD");
        public final static Property TimeMode_CD = new Property(5, String.class, "TimeMode_CD", false, "TIMEMODE_CD");
        public final static Property CycTime_NR = new Property(6, int.class, "CycTime_NR", false, "CYCTIME_NR");
        public final static Property StartTimeList_TX = new Property(7, String.class, "StartTimeList_TX", false, "STARTTIMELIST_TX");
        public final static Property EndTimeList_TX = new Property(8, String.class, "EndTimeList_TX", false, "ENDTIMELIST_TX");
        public final static Property ShiftList_TX = new Property(9, String.class, "ShiftList_TX", false, "SHIFTLIST_TX");
        public final static Property OverDayList_TX = new Property(10, String.class, "OverDayList_TX", false, "OVERDAYLIST_TX");
        public final static Property OtherList_TX = new Property(11, String.class, "OtherList_TX", false, "OTHERLIST_TX");
        public final static Property MObjectState_TX = new Property(12, String.class, "MObjectState_TX", false, "MOBJECTSTATE_TX");
    };


    public Z_DJ_CycleDTLDao(DaoConfig config) {
        super(config);
    }
    
    public Z_DJ_CycleDTLDao(DaoConfig config, DJDAOSession daoSession) {
        super(config, daoSession);
    }

    /** Creates the underlying database table. */
    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
        String constraint = ifNotExists? "IF NOT EXISTS ": "";
        db.execSQL("CREATE TABLE " + constraint + "'Z_DJ_CYCLE_DTL' (" + //
                "'CYCLE_ID' TEXT NOT NULL ," + // 0: Cycle_ID
                "'CYC_SORT_NR' INTEGER NOT NULL ," + // 1: CycSort_NR
                "'CYC_START_TX' TEXT NOT NULL ," + // 2: CycStart_TX
                "'SPAN_VALUE_NR' INTEGER NOT NULL ," + // 3: SpanValue_NR
                "'SPAN_TYPE_CD' TEXT NOT NULL ," + // 4: SpanType_CD
                "'TIME_MODE_CD' TEXT NOT NULL ," + // 5: TimeMode_CD
                "'CYC_TIME_NR' INTEGER NOT NULL ," + // 6: CycTime_NR
                "'START_TIME_LIST_TX' TEXT," + // 7: StartTimeList_TX
                "'END_TIME_LIST_TX' TEXT," + // 8: EndTimeList_TX
                "'SHIFT_LIST_TX' TEXT," + // 9: ShiftList_TX
                "'OVER_DAY_LIST_TX' TEXT," + // 10: OverDayList_TX
                "'OTHER_LIST_TX' TEXT," + // 11: OtherList_TX
                "'MOBJECT_STATE_TX' TEXT);"); // 12: MObjectState_TX
    }

    /** Drops the underlying database table. */
    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'Z_DJ_CYCLE_DTL'";
        db.execSQL(sql);
    }

    /** @inheritdoc */
    @Override
    protected void bindValues(SQLiteStatement stmt, Z_DJ_CycleDTL entity) {
        stmt.clearBindings();
        stmt.bindString(1, entity.getCycle_ID());
        stmt.bindLong(2, entity.getCycSort_NR());
        stmt.bindString(3, entity.getCycStart_TX());
        stmt.bindLong(4, entity.getSpanValue_NR());
        stmt.bindString(5, entity.getSpanType_CD());
        stmt.bindString(6, entity.getTimeMode_CD());
        stmt.bindLong(7, entity.getCycTime_NR());
 
        String StartTimeList_TX = entity.getStartTimeList_TX();
        if (StartTimeList_TX != null) {
            stmt.bindString(8, StartTimeList_TX);
        }
 
        String EndTimeList_TX = entity.getEndTimeList_TX();
        if (EndTimeList_TX != null) {
            stmt.bindString(9, EndTimeList_TX);
        }
 
        String ShiftList_TX = entity.getShiftList_TX();
        if (ShiftList_TX != null) {
            stmt.bindString(10, ShiftList_TX);
        }
 
        String OverDayList_TX = entity.getOverDayList_TX();
        if (OverDayList_TX != null) {
            stmt.bindString(11, OverDayList_TX);
        }
 
        String OtherList_TX = entity.getOtherList_TX();
        if (OtherList_TX != null) {
            stmt.bindString(12, OtherList_TX);
        }
 
        String MObjectState_TX = entity.getMObjectState_TX();
        if (MObjectState_TX != null) {
            stmt.bindString(13, MObjectState_TX);
        }
    }

    /** @inheritdoc */
    @Override
    public Void readKey(Cursor cursor, int offset) {
        return null;
    }    

    /** @inheritdoc */
    @Override
    public Z_DJ_CycleDTL readEntity(Cursor cursor, int offset) {
        Z_DJ_CycleDTL entity = new Z_DJ_CycleDTL( //
            cursor.getString(offset + 0), // Cycle_ID
            cursor.getInt(offset + 1), // CycSort_NR
            cursor.getString(offset + 2), // CycStart_TX
            cursor.getInt(offset + 3), // SpanValue_NR
            cursor.getString(offset + 4), // SpanType_CD
            cursor.getString(offset + 5), // TimeMode_CD
            cursor.getInt(offset + 6), // CycTime_NR
            cursor.isNull(offset + 7) ? null : cursor.getString(offset + 7), // StartTimeList_TX
            cursor.isNull(offset + 8) ? null : cursor.getString(offset + 8), // EndTimeList_TX
            cursor.isNull(offset + 9) ? null : cursor.getString(offset + 9), // ShiftList_TX
            cursor.isNull(offset + 10) ? null : cursor.getString(offset + 10), // OverDayList_TX
            cursor.isNull(offset + 11) ? null : cursor.getString(offset + 11), // OtherList_TX
            cursor.isNull(offset + 12) ? null : cursor.getString(offset + 12) // MObjectState_TX
        );
        return entity;
    }
     
    /** @inheritdoc */
    @Override
    public void readEntity(Cursor cursor, Z_DJ_CycleDTL entity, int offset) {
        entity.setCycle_ID(cursor.getString(offset + 0));
        entity.setCycSort_NR(cursor.getInt(offset + 1));
        entity.setCycStart_TX(cursor.getString(offset + 2));
        entity.setSpanValue_NR(cursor.getInt(offset + 3));
        entity.setSpanType_CD(cursor.getString(offset + 4));
        entity.setTimeMode_CD(cursor.getString(offset + 5));
        entity.setCycTime_NR(cursor.getInt(offset + 6));
        entity.setStartTimeList_TX(cursor.isNull(offset + 7) ? null : cursor.getString(offset + 7));
        entity.setEndTimeList_TX(cursor.isNull(offset + 8) ? null : cursor.getString(offset + 8));
        entity.setShiftList_TX(cursor.isNull(offset + 9) ? null : cursor.getString(offset + 9));
        entity.setOverDayList_TX(cursor.isNull(offset + 10) ? null : cursor.getString(offset + 10));
        entity.setOtherList_TX(cursor.isNull(offset + 11) ? null : cursor.getString(offset + 11));
        entity.setMObjectState_TX(cursor.isNull(offset + 12) ? null : cursor.getString(offset + 12));
     }
    
    /** @inheritdoc */
    @Override
    protected Void updateKeyAfterInsert(Z_DJ_CycleDTL entity, long rowId) {
        // Unsupported or missing PK type
        return null;
    }
    
    /** @inheritdoc */
    @Override
    public Void getKey(Z_DJ_CycleDTL entity) {
        return null;
    }

    /** @inheritdoc */
    @Override    
    protected boolean isEntityUpdateable() {
        return true;
    }
    
}
